/// A testing framework for writing and organizing tests in Lazylang.
///
/// This module provides a BDD-style testing DSL with:
/// - **Test organization**: [describe], [it], [xit]
/// - **Assertions**: [mustEq], [mustNotEq], [must]
/// - **Test control**: [pass], [fail]
/// - **Property-based testing**: [forall], [forallWith]
///
/// ## Examples
///
/// ```
/// { describe, it, mustEq } = import 'Spec'
///
/// describe "Math operations" [
///   it "adds numbers correctly" do
///     result = 2 + 3
///     mustEq 5 result
///
///   it "multiplies numbers correctly" do
///     result = 2 * 5
///     mustEq 10 result
/// ]
/// ```
///
/// ## Test Structure
///
/// Tests are organized into suites using [describe] blocks, which contain
/// individual test cases defined with [it]. Use [xit] to temporarily skip tests.
///
/// ## Assertions
///
/// - [mustEq]: Checks equality between expected and actual values
/// - [mustNotEq]: Checks inequality between values
/// - [must]: Checks that a condition is truthy
///
/// Tests pass automatically if they don't throw errors. Use [pass] and [fail]
/// for explicit control.
///
/// ## Property-Based Testing
///
/// Use [forall] to run property tests with randomly generated values:
///
/// ```
/// describe "String" [
///   describe "reverse" [
///     forall Random.string "reversing twice yields original" do str ->
///       mustEq str (String.reverse (String.reverse str))
///   ]
/// ]
///
/// describe "Math" [
///   forall Random.int "absolute value is non-negative" do n ->
///     must (Math.abs n >= 0)
/// ]
/// ```
/// ---
Array = import "Array"
Object = import "Object"
Random = import "Random"
Result = import "Result"

{
  /// Explicitly marks a test as passing.
  /// Useful for tests that verify side effects or when you want to document expected behavior.
  ///
  /// **Example:**
  /// ```
  /// it "evaluates without error" do
  ///   x = 2 + 2
  ///   pass
  /// ```
  pass: {
    type: "pass"
  }

  /// Explicitly marks a test as failing with a custom message or details.
  /// Useful for tests that should fail under certain conditions or for documenting known issues.
  ///
  /// **Parameters:**
  /// - `details`: A string message or an object with failure details (kind, expected, actual, condition)
  ///
  /// **Example:**
  /// ```
  /// it "validates input" do
  ///   input = "invalid"
  ///   if (input == "invalid") then
  ///     fail "Input validation failed"
  ///   else
  ///     pass
  ///
  /// it "provides structured failure details" do
  ///   fail { kind: "eq", expected: 5, actual: 10 }
  /// ```
  fail: details -> {
    type: "fail"
    details: details
  }

  /// Creates a test suite with a description and child tests.
  /// Used to organize related tests into groups.
  ///
  /// **Parameters:**
  /// - `description`: A string describing what is being tested
  /// - `children`: An array of test cases or nested describe blocks
  ///
  /// **Example:**
  /// ```
  /// describe "Array operations" [
  ///   it "concatenates arrays" do
  ///     result = [1, 2] ++ [3]
  ///     mustEq [1, 2, 3] result
  /// ]
  /// ```
  describe: description -> children -> {
    type: "describe"
    description: description
    children: children
  }

  /// Creates an individual test case with a description and test expression.
  ///
  /// **Parameters:**
  /// - `description`: A string describing what should happen
  /// - `testExpr`: An assertion expression to validate the test
  ///
  /// **Example:**
  /// ```
  /// it "adds two numbers correctly" do
  ///   result = 2 + 3
  ///   mustEq 5 result
  /// ```
  it: description -> testExpr -> {
    type: "it"
    description: description
    test: testExpr
  }

  /// Creates an ignored test case that will be skipped during test execution.
  /// Useful for temporarily disabling tests without removing them.
  ///
  /// **Parameters:**
  /// - `description`: A string describing what should happen
  /// - `testExpr`: An assertion expression (not evaluated)
  ///
  /// **Example:**
  /// ```
  /// xit "adds two numbers correctly" do
  ///   result = 2 + 3
  ///   mustEq 5 result
  /// ```
  xit: description -> testExpr -> {
    type: "xit"
    description: description
    test: testExpr
  }

  /// Creates an equality assertion that checks if the actual value matches the expected value.
  /// The test passes if both values are equal, otherwise it fails.
  ///
  /// **Parameters:**
  /// - `expected`: The expected value
  /// - `actual`: The actual value to compare
  ///
  /// **Example:**
  /// ```
  /// mustEq 42 actualValue
  /// mustEq [1, 2, 3] resultArray
  /// mustEq { name: "John" } resultObject
  /// ```
  mustEq: expected -> actual ->
    if (expected == actual) then
      { type: "pass" }
    else
      {
        type: "fail"
        details: {
          kind: "eq"
          expected: expected
          actual: actual
        }
      }

  /// Creates an inequality assertion that checks if the actual value does NOT match the expected value.
  /// The test passes if both values are different, otherwise it fails.
  ///
  /// **Parameters:**
  /// - `expected`: The value that should NOT be matched
  /// - `actual`: The actual value to compare
  ///
  /// **Example:**
  /// ```
  /// mustNotEq 0 actualValue
  /// mustNotEq null result
  /// ```
  mustNotEq: expected -> actual ->
    if (expected != actual) then
      { type: "pass" }
    else
      {
        type: "fail"
        details: {
          kind: "notEq"
          expected: expected
          actual: actual
        }
      }

  /// Creates a truthiness assertion that checks if the condition is truthy.
  /// The test passes if the condition evaluates to true, otherwise it fails.
  ///
  /// **Parameters:**
  /// - `condition`: The value or expression to check for truthiness
  ///
  /// **Example:**
  /// ```
  /// must (x > 0)
  /// must (Array.length arr == 3)
  /// ```
  must: condition ->
    if ((condition == null) || (condition == false)) then
      {
        type: "fail"
        details: {
          kind: "truthy"
          condition: condition
        }
      }
    else
      { type: "pass" }

  /// Runs property-based tests with randomly generated values.
  /// Tests the same property across multiple randomly generated inputs to find edge cases.
  ///
  /// **Parameters:**
  /// - `generator`: A Random generator function (e.g., Random.int, Random.intRange 0 100)
  /// - `description`: Description of the property being tested
  /// - `testFn`: A function that takes a generated value and returns an assertion
  ///
  /// **Defaults:**
  /// - Runs 100 trials
  /// - Uses seed 42 for reproducibility
  ///
  /// **Example:**
  /// ```
  /// forall Random.int "absolute value is non-negative" do n ->
  ///   must (Math.abs n >= 0)
  ///
  /// forall (Random.intRange 0 100) "value is in range" do n ->
  ///   must (n >= 0 && n <= 100)
  /// ```
  forall: generator -> description -> testFn ->
    trials = 100

    // Return a function that takes a seed and runs the property test
    runPropertyTest = seed ->
      baseSeed = Random.seed seed

      // Generate all trial test values
      generateValues = n -> s -> acc ->
        if n <= 0 then
          Array.reverse acc
        else
          (value, nextSeed) = generator s
          generateValues (n - 1) nextSeed [...acc, value]

      testValues = generateValues trials baseSeed []

      // Stop on first failure, otherwise continue testing
      stopOnFailure = result -> value ->
        if result.type == "fail" then
          result
        else
          testFn value

      Array.fold stopOnFailure { type: "pass" } testValues

    {
      type: "property"
      description: description
      test: runPropertyTest
      trials: trials
    }

  /// Runs property-based tests with custom configuration.
  /// Like [forall] but allows specifying number of trials and seed.
  ///
  /// **Parameters:**
  /// - `options`: Object with optional fields: { trials: Int, seed: Int }
  /// - `generator`: A Random generator function
  /// - `description`: Description of the property being tested
  /// - `testFn`: A function that takes a generated value and returns an assertion
  ///
  /// **Example:**
  /// ```
  /// forallWith { trials: 50, seed: 12345 } Random.int "property holds" do value ->
  ///   must (property value)
  /// ```
  forallWith: options -> generator -> description -> testFn ->
    trials = Object.get "trials" options
      \ Result.orDefault 100
    seedOverride = Object.get "seed" options
      \ Result.orDefault null

    // Return a function that takes a seed and runs the property test
    runPropertyTest = seed ->
      // Use override if provided, otherwise use the passed seed
      baseSeed = if seedOverride == null then
        Random.seed seed
      else
        Random.seed seedOverride

      // Generate all trial test values
      generateValues = n -> s -> acc ->
        if n <= 0 then
          Array.reverse acc
        else
          (value, nextSeed) = generator s
          generateValues (n - 1) nextSeed [...acc, value]

      testValues = generateValues trials baseSeed []

      // Stop on first failure, otherwise continue testing
      stopOnFailure = result -> value ->
        if result.type == "fail" then
          result
        else
          testFn value

      Array.fold stopOnFailure { type: "pass" } testValues

    {
      type: "property"
      description: description
      test: runPropertyTest
      trials: trials
    }

  /// Runs a spec suite with a given seed and returns a structured report.
  ///
  /// **Parameters:**
  /// - `config`: Object with { suite, seed } where suite is the test structure and seed is an integer
  ///
  /// **Returns:**
  /// An object with { passed, failed, ignored, results } where results is an array of test outcomes
  ///
  /// **Example:**
  /// ```
  /// suite = describe "Math" [
  ///   it "adds" do mustEq 5 (2 + 3)
  /// ]
  /// report = run { suite: suite, seed: 42 }
  /// ```
  run: config ->
    suite = config.suite
    seed = config.seed

    runItem = item -> s -> path ->
      itemType = Object.get "type" item \ Result.orDefault "unknown"
      base = { passed: 0, failed: 0, ignored: 0, results: [] }

      when itemType matches
        "describe" then (
          description = Object.get "description" item \ Result.orDefault "unknown"
          children = Object.get "children" item \ Result.orDefault []
          newPath = [...path, description]

          // Recursively process children
          processChildren = idx -> acc ->
            if idx >= Array.length children then
              acc
            else
              child = Array.get idx children \ Result.orDefault null
              childResult = runItem child s newPath
              newAcc = {
                passed: acc.passed + childResult.passed
                failed: acc.failed + childResult.failed
                ignored: acc.ignored + childResult.ignored
                results: [...acc.results, ...childResult.results]
              }
              processChildren (idx + 1) newAcc

          processChildren 0 base
        )

        "it" then (
          description = Object.get "description" item \ Result.orDefault "unknown"
          testResult = Object.get "test" item \ Result.orDefault { type: "pass" }
          resultType = Object.get "type" testResult \ Result.orDefault "unknown"
          details = Object.get "details" testResult \ Result.orDefault null

          if resultType == "pass" then
            base { passed: 1, results: [{ type: "pass", path, description }] }
          else if resultType == "fail" then
            base { failed: 1, results: [{ type: "fail", path, description, details }] }
          else
            base { passed: 1, results: [{ type: "pass", path, description }] }
        )

        "xit" then (
          description = Object.get "description" item \ Result.orDefault "unknown"
          base { ignored: 1, results: [{ type: "ignored", path, description }] }
        )

        "property" then (
          description = Object.get "description" item \ Result.orDefault "unknown"
          testFn = Object.get "test" item \ Result.orDefault (x -> { type: "pass" })
          result = testFn s
          resultType = Object.get "type" result \ Result.orDefault "unknown"
          details = Object.get "details" result \ Result.orDefault null

          if resultType == "pass" then
            base { passed: 1, results: [{ type: "pass", path, description }] }
          else
            base { failed: 1, results: [{ type: "fail", path, description, details }] }
        )

        otherwise
        base { failed: 1, results: [{ type: "error", path, description: "Unknown type" }] }

    runItem suite seed []
}
