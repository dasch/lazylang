/// Provides utilities for working with integer ranges in Lazylang.
///
/// Ranges represent sequences of integers without materializing them into arrays.
/// This makes them memory-efficient for large sequences.
///
/// ## Creating Ranges
///
/// - `Range.inclusive start end`: Creates an inclusive range [start..end]
/// - `Range.exclusive start end`: Creates an exclusive range [start...end)
///
/// ## Converting to Arrays
///
/// - `Range.toArray range`: Converts a range to an array
///
/// ## Syntactic Sugar
///
/// - `start..end`: Creates an inclusive range (same as `Range.inclusive start end`)
/// - `start...end`: Creates an exclusive range (same as `Range.exclusive start end`)
///
/// ## Examples
///
/// ```
/// // Using functions
/// Range.inclusive 1 5      // Range from 1 to 5 (inclusive)
/// Range.exclusive 1 5      // Range from 1 to 4 (exclusive)
///
/// // Using syntactic sugar
/// 1..5                     // Range from 1 to 5 (inclusive)
/// 1...5                    // Range from 1 to 4 (exclusive)
///
/// // Converting to arrays
/// Range.toArray (1..5)     // [1, 2, 3, 4, 5]
/// Range.toArray (1...5)    // [1, 2, 3, 4]
///
/// // Using in for loops
/// [x * 2 for x in 1..5]    // [2, 4, 6, 8, 10]
/// ```
{
  /// Creates an inclusive range from start to end.
  /// The end value is included in the range.
  ///
  /// **Parameters:**
  /// - `start`: The starting integer (inclusive)
  /// - `end`: The ending integer (inclusive)
  ///
  /// **Returns:**
  /// A Range value representing the sequence [start, start+1, ..., end]
  ///
  /// **Example:**
  /// ```
  /// Range.inclusive 1 5      // Range: 1, 2, 3, 4, 5
  /// Range.inclusive 0 0      // Range: 0
  /// Range.inclusive 5 3      // Empty range (start > end)
  /// ```
  inclusive: start -> end -> __range_inclusive (start, end)

  /// Creates an exclusive range from start to end.
  /// The end value is NOT included in the range.
  ///
  /// **Parameters:**
  /// - `start`: The starting integer (inclusive)
  /// - `end`: The ending integer (exclusive)
  ///
  /// **Returns:**
  /// A Range value representing the sequence [start, start+1, ..., end-1]
  ///
  /// **Example:**
  /// ```
  /// Range.exclusive 1 5      // Range: 1, 2, 3, 4
  /// Range.exclusive 0 1      // Range: 0
  /// Range.exclusive 5 5      // Empty range (start >= end)
  /// ```
  exclusive: start -> end -> __range_exclusive (start, end)

  /// Converts a range to an array.
  ///
  /// **Parameter:**
  /// - `range`: The range to convert
  ///
  /// **Returns:**
  /// An array containing all integers in the range
  ///
  /// **Example:**
  /// ```
  /// Range.toArray (Range.inclusive 1 5)    // [1, 2, 3, 4, 5]
  /// Range.toArray (Range.exclusive 1 5)    // [1, 2, 3, 4]
  /// Range.toArray (1..5)                   // [1, 2, 3, 4, 5]
  /// Range.toArray (1...5)                  // [1, 2, 3, 4]
  /// ```
  toArray: range -> __range_to_array range

  /// Checks if a value is within a range.
  ///
  /// **Parameters:**
  /// - `range`: The range to check against
  /// - `x`: The integer value to check
  ///
  /// **Returns:**
  /// true if x is within the range, false otherwise
  ///
  /// **Example:**
  /// ```
  /// Range.covers (1..5) 3      // true
  /// Range.covers (1..5) 1      // true (inclusive start)
  /// Range.covers (1..5) 5      // true (inclusive end)
  /// Range.covers (1..5) 0      // false
  /// Range.covers (1..5) 6      // false
  /// Range.covers (1...5) 5     // false (exclusive end)
  /// Range.covers (1...5) 4     // true
  /// ```
  covers: range -> x -> __range_covers (range, x)

  /// Combines two ranges into an array of tuples, pairing elements at the same position.
  /// If the ranges have different lengths, the shorter range's remaining positions
  /// are filled with `null`.
  ///
  /// **Parameters:**
  /// - `range1`: The first range
  /// - `range2`: The second range
  ///
  /// **Returns:**
  /// An array of tuples where each tuple contains `(element from range1, element from range2)`
  ///
  /// **Example:**
  /// ```
  /// Range.zip (1..3) (10..12)
  /// // Returns [(1, 10), (2, 11), (3, 12)]
  ///
  /// Range.zip (1..5) (10..11)
  /// // Returns [(1, 10), (2, 11), (3, null), (4, null), (5, null)]
  ///
  /// Range.zip (1...3) (10..15)
  /// // Returns [(1, 10), (2, 11), (null, 12), (null, 13), (null, 14), (null, 15)]
  /// ```
  zip: range1 -> range2 ->
    arr1 = __range_to_array range1;
    arr2 = __range_to_array range2;
    len1 = __array_length arr1;
    len2 = __array_length arr2;
    maxLen = if len1 > len2 then len1 else len2;
    getOrNull = idx -> arr -> len ->
      if idx < len then
        when __array_get (arr, idx) matches
          (#ok, val) then val
          otherwise null
      else
        null;
    [
      (getOrNull i arr1 len1, getOrNull i arr2 len2)
      for i in 0...maxLen
    ]
}
