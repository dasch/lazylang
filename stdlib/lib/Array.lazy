/// Provides utilities for working with arrays in Lazylang.
///
/// This module includes functions for common array operations such as:
/// - **Querying**: [length], [get], [isEmpty]
/// - **Transforming**: [map], [flatMap], [filter], [skip], [reverse], [concat], [slice], [sort], [sortBy], [uniq], [groupBy]
/// - **Reducing**: [fold], [all], [any], [none]
///
/// ## Examples
///
/// ```
/// // Transform elements
/// Array.map (x -> x * 2) [1, 2, 3]  //=> [2, 4, 6]
///
/// // Filter elements
/// Array.filter (x -> x > 2) [1, 2, 3, 4]  //=> [3, 4]
///
/// // Reduce to a single value
/// Array.fold (acc -> x -> acc + x) 0 [1, 2, 3]  //=> 6
/// ```
/// ---
Result = import "Result"
Tuple = import "Tuple"

{
  /// Returns the number of elements in an array.
  ///
  /// **Parameter:**
  /// - `arr`: The array to get the length of
  ///
  /// **Example:**
  /// ```
  /// Array.length [1, 2, 3]  //=> 3
  /// ```
  length: arr -> __array_length arr

  /// Retrieves the element at the specified index in an array.
  /// Returns `(#ok, value)` if the index is valid, or `#outOfBounds` if the index is out of range.
  ///
  /// **Parameters:**
  /// - `idx`: The zero-based index of the element to retrieve
  /// - `arr`: The array to access
  ///
  /// **Returns:**
  /// - `(#ok, value)`: When the index is within bounds
  /// - `#outOfBounds`: When the index is negative or >= array length
  ///
  /// **Example:**
  /// ```
  /// Array.get 1 [10, 20, 30]  //=> (#ok, 20)
  /// Array.get 5 [10, 20, 30]  //=> #outOfBounds
  /// ```
  get: idx -> arr -> __array_get (arr, idx)

  /// Applies a function to each element of an array, returning a new array.
  ///
  /// **Parameters:**
  /// - `fn`: Function to apply to each element
  /// - `arr`: The array to map over
  ///
  /// **Example:**
  /// ```
  /// Array.map (x -> x * 2) [1, 2, 3]  //=> [2, 4, 6]
  /// ```
  map: fn -> arr -> [fn x for x in arr]

  /// Applies a function to each element and flattens the results into a single array.
  ///
  /// **Parameters:**
  /// - `fn`: Function that returns an array for each element
  /// - `arr`: The array to flatMap over
  ///
  /// **Example:**
  /// ```
  /// Array.flatMap (x -> [x, x]) [1, 2]  //=> [1, 1, 2, 2]
  /// ```
  flatMap: fn -> arr -> [y for x in arr for y in (fn x)]

  /// Filters an array, keeping only elements that satisfy the predicate.
  ///
  /// **Parameters:**
  /// - `pred`: Predicate function that returns true for elements to keep
  /// - `arr`: The array to filter
  ///
  /// **Example:**
  /// ```
  /// Array.filter (x -> x > 2) [1, 2, 3, 4]  //=> [3, 4]
  /// ```
  filter: pred -> arr -> [x for x in arr when pred x]

  /// Filters an array, removing elements that satisfy the predicate (opposite of filter).
  ///
  /// **Parameters:**
  /// - `pred`: Predicate function that returns true for elements to remove
  /// - `arr`: The array to filter
  ///
  /// **Example:**
  /// ```
  /// Array.skip (x -> x > 2) [1, 2, 3, 4]  //=> [1, 2]
  /// ```
  skip: pred -> arr -> [x for x in arr when !(pred x)]

  /// Folds an array from the left using an accumulator function.
  ///
  /// **Parameters:**
  /// - `fn`: Binary function (acc -> elem -> new_acc)
  /// - `init`: Initial accumulator value
  /// - `arr`: The array to fold
  ///
  /// **Example:**
  /// ```
  /// Array.fold (acc -> x -> acc + x) 0 [1, 2, 3]  //=> 6
  /// Array.fold (acc -> x -> acc * x) 1 [2, 3, 4]  //=> 24
  /// ```
  fold: fn -> init -> arr ->
    foldHelper = f -> acc -> xs -> idx ->
      if idx >= __array_length xs then
        acc
      else
        when __array_get (xs, idx) matches
          (#ok, x) then foldHelper f (f acc x) xs (idx + 1)
          otherwise acc
    foldHelper fn init arr 0

  /// Reverses an array.
  ///
  /// **Parameter:**
  /// - `arr`: The array to reverse
  ///
  /// **Example:**
  /// ```
  /// Array.reverse [1, 2, 3]  //=> [3, 2, 1]
  /// Array.reverse []  //=> []
  /// ```
  reverse: arr -> __array_reverse arr

  /// Concatenates an array of arrays into a single array.
  /// Also known as "flatten" in some languages.
  ///
  /// **Parameter:**
  /// - `arrays`: Array of arrays to concatenate
  ///
  /// **Example:**
  /// ```
  /// Array.concat [[1, 2], [3, 4]]  //=> [1, 2, 3, 4]
  /// Array.concat [[], [1], [2, 3]]  //=> [1, 2, 3]
  /// Array.concat []  //=> []
  /// ```
  concat: arrays -> [x for arr in arrays for x in arr]

  /// Returns an empty array.
  ///
  /// **Example:**
  /// ```
  /// Array.empty  //=> []
  /// ```
  empty: []

  /// Checks if an array is empty.
  ///
  /// **Parameter:**
  /// - `arr`: The array to check
  ///
  /// **Example:**
  /// ```
  /// Array.isEmpty []  //=> true
  /// Array.isEmpty [1, 2, 3]  //=> false
  /// ```
  isEmpty: arr -> __array_length arr == 0

  /// Extracts a slice of an array from start (inclusive) to end (exclusive).
  /// Supports negative indices (counting from the end).
  ///
  /// **Parameters:**
  /// - `start`: The starting index (inclusive)
  /// - `end`: The ending index (exclusive)
  /// - `arr`: The array to slice
  ///
  /// **Example:**
  /// ```
  /// Array.slice 1 3 [0, 1, 2, 3, 4]  //=> [1, 2]
  /// Array.slice 0 2 ["a", "b", "c"]  //=> ["a", "b"]
  /// Array.slice (0 - 2) 5 [1, 2, 3, 4]  //=> [3, 4]
  /// ```
  slice: start -> end -> arr -> __array_slice (start, end, arr)

  /// Sorts an array in ascending order.
  /// Works with integers and strings.
  ///
  /// **Parameter:**
  /// - `arr`: The array to sort
  ///
  /// **Example:**
  /// ```
  /// Array.sort [3, 1, 4, 1, 5]  //=> [1, 1, 3, 4, 5]
  /// Array.sort ["c", "a", "b"]  //=> ["a", "b", "c"]
  /// ```
  sort: arr -> __array_sort arr

  /// Sorts an array by a computed key function.
  ///
  /// **Parameters:**
  /// - `keyFn`: Function that returns the sort key for each element
  /// - `arr`: The array to sort
  ///
  /// **Example:**
  /// ```
  /// Array.sortBy .age [{name: "Alice", age: 30}, {name: "Bob", age: 25}] \
  ///   //=> [{name: "Bob", age: 25}, {name: "Alice", age: 30}]
  /// ```
  sortBy: keyFn -> arr ->
    // Create array of (key, value) pairs
    pairs = [{ key: keyFn x, value: x } for x in arr]
    // Sort pairs by key
    sorted = __array_sort [p.key for p in pairs]
    // Map back to find original values
    [p.value for sortedKey in sorted for p in pairs when p.key == sortedKey]

  /// Returns an array with duplicate elements removed.
  /// Preserves the first occurrence of each unique element.
  ///
  /// **Parameter:**
  /// - `arr`: The array to deduplicate
  ///
  /// **Example:**
  /// ```
  /// Array.uniq [1, 2, 2, 3, 1, 4]  //=> [1, 2, 3, 4]
  /// Array.uniq ["a", "b", "a"]  //=> ["a", "b"]
  /// ```
  uniq: arr -> __array_uniq arr

  /// Tests whether all elements satisfy a predicate.
  ///
  /// **Parameters:**
  /// - `pred`: Predicate function to test each element
  /// - `arr`: The array to test
  ///
  /// **Example:**
  /// ```
  /// Array.all (x -> x > 0) [1, 2, 3]  //=> true
  /// Array.all (x -> x > 0) [1, -2, 3]  //=> false
  /// Array.all (x -> x > 0) []  //=> true
  /// ```
  all: pred -> arr -> __array_fold ((acc -> x -> acc && pred x), true, arr)

  /// Tests whether any element satisfies a predicate.
  ///
  /// **Parameters:**
  /// - `pred`: Predicate function to test each element
  /// - `arr`: The array to test
  ///
  /// **Example:**
  /// ```
  /// Array.any (x -> x > 2) [1, 2, 3]  //=> true
  /// Array.any (x -> x > 5) [1, 2, 3]  //=> false
  /// Array.any (x -> x > 0) []  //=> false
  /// ```
  any: pred -> arr -> __array_fold ((acc -> x -> acc || pred x), false, arr)

  /// Tests whether no elements satisfy a predicate.
  ///
  /// **Parameters:**
  /// - `pred`: Predicate function to test each element
  /// - `arr`: The array to test
  ///
  /// **Example:**
  /// ```
  /// Array.none (x -> x > 5) [1, 2, 3]  //=> true
  /// Array.none (x -> x > 2) [1, 2, 3]  //=> false
  /// Array.none (x -> x > 0) []  //=> true
  /// ```
  none: pred -> arr -> __array_fold ((acc -> x -> acc && !(pred x)), true, arr)

  /// Groups array elements by a computed key function.
  /// Returns an object where keys are the unique results of the key function,
  /// and values are arrays of elements that produced that key.
  ///
  /// **Parameters:**
  /// - `keyFn`: Function that computes the grouping key for each element
  /// - `arr`: The array to group
  ///
  /// **Example:**
  /// ```
  /// Array.groupBy .type [ \
  ///   {type: "fruit", name: "apple"}, \
  ///   {type: "fruit", name: "banana"}, \
  ///   {type: "vegetable", name: "carrot"} \
  /// ] //=> { \
  ///   fruit: [{type: "fruit", name: "apple"}, {type: "fruit", name: "banana"}], \
  ///   vegetable: [{type: "vegetable", name: "carrot"}] \
  /// }
  /// ```
  groupBy: keyFn -> arr ->
    keys = __array_uniq [keyFn x for x in arr]
    { [k]: [x for x in arr when keyFn x == k] for k in keys }

  /// Combines two arrays into an array of tuples, pairing elements at the same index.
  /// If the arrays have different lengths, the shorter array's remaining positions
  /// are filled with `null`.
  ///
  /// **Parameters:**
  /// - `arr1`: The first array
  /// - `arr2`: The second array
  ///
  /// **Returns:**
  /// An array of tuples where each tuple contains `(element from arr1, element from arr2)`
  ///
  /// **Example:**
  /// ```
  /// Array.zip ["a", "b", "c"] [1, 2] \
  ///   //=> [("a", 1), ("b", 2), ("c", null)]
  ///
  /// Array.zip [1, 2] [3, 4, 5] \
  ///   //=> [(1, 3), (2, 4), (null, 5)]
  ///
  /// Array.zip [] [1, 2] \
  ///   //=> [(null, 1), (null, 2)]
  /// ```
  zip: arr1 -> arr2 ->
    len1 = __array_length arr1;
    len2 = __array_length arr2;
    maxLen = if len1 > len2 then len1 else len2;
    [
      Tuple.mapBoth (Result.orDefault null) (__array_get (arr1, i), __array_get (arr2, i))
      for i in 0...maxLen
    ]
}
